graph[i][j] = 1 or wt (matrix but not usefull because of space complexity) O(n^2)

graph[i].push_back(j); (list useful) O(v + e) O(2 * E) --> undirected , O(E) --> direceted

wity weight 
graph[i].push_back({j, wt});

-----------------------------------------------------------------------------------------

                            (DFS)

void dfs(ll vertex){
    // take action after enter into the vertex
    visited[vertex] = true;
    for(auto child : graph[vertex]){
        if(visited[child]){
            cotninue;
        }
        // take action before call the dfs for child
        dfs(child);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

O(N + E)

cycle detection and connected component

---------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        depth[child] = depth[vertex] + 1;
        dfs(child);
        height[vertex] = max(height[vertex], height[child] + 1);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

-------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    subtree_sum[vertex] += vertex;
    even_cnt[vertex] = (vertex % 2);
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        dfs(child);
        subtree_sum[vertex] += subtree_sum[child];
        even_cnt[vertex] += even_cnt[child];
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

-------------------------------------------------------------------------------------

To find diameter of tree is 
first stemp --> take any node of tree and run dfs
find max depth node;
and second stemp --> take that node and run dfs and max value is diameter.

------------------------------------------------------------------------------------

            (LCA)

run dfs and store parent of all node
take one node and call function path return path

compare min(both path) longest comman node is LCA.

par[vertex] = p;

-------------------------------------------------------------------------------

void bfs(int source){
    queue<int> Q;
    Q.push(source);
    while(!Q.empty()){
        auto i = Q.front();
        Q.pop();
        for(auto child : graph[i]){
            if(!visited[child]){
                Q.push(child);
                visited[child] = true;
                level[child] = level[i] + 1;
            }
        }
    }
}

O(v + e);

O(V) + O(2 * E) --> time

O(3N) --> space

----------------------------------------------------------------------------

0-1 bfs
if edges weight is 0 then add to front of the queue
otherwise add back of the queue

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); 
    ll T = 1;
    // cin >> T;
    while(T--){
        int n, m; cin >> n >> m;
        vector<vector<pair<int, int>>> graph(n + 1);
        fori(i, 0, m){
            int u, v; cin >> u >> v;
            graph[u].pb({v, 0});
            graph[v].pb({u, 1});
        }
        vector<int> level(n + 1, INT_MAX);
        deque<int> Q;
        level[1] = 0;
        Q.push_back(1);
        while(!Q.empty()){
            auto i = Q.front();
            Q.pop_front();
            for(auto child : graph[i]){
                int a = child.first;
                int b = child.second;
                if(level[i] + b < level[a]){
                    level[a] = level[i] + b;
                    if(b){
                        Q.push_back(a);
                    }else{
                        Q.push_front(a);
                    }
                }
            }
        }
        level[n] == INT_MAX ? c(-1) : c(level[n]);
        sahil:; 
    }
    return 0;
}

------------------------------------------------------------------------

                    (Multi-Source BFS)

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); 
    ll T;
    cin >> T;
    while(T--){
        ll n, m; cin >> n >> m;
        vector<vector<ll>> v(n, vector<ll> (m));
        ll mx = -1;
        fori(i, 0, n){
            fori(j, 0, m){
                cin >> v[i][j];
                mx = max(mx, v[i][j]);
            }
        }
        queue<pair<ll, ll>> Q;
        vector<vector<ll>> level(n, vector<ll> (m, INT_MAX)); 
        fori(i, 0, n){
            fori(j, 0, m){
                if(v[i][j] == mx){
                    Q.push({i, j});
                    level[i][j] = 0;
                }
            }
        }
        vector<pair<ll, ll>> movement = {
            {0, -1}, {-1, 0}, {1, 0}, {0, 1},
            {1, 1}, {1, -1}, {-1, 1}, {-1, -1} 
        };
        ll ans = 0;
        while(!Q.empty()){
            auto i = Q.front();
            Q.pop();
            ll x = i.ff, y = i.ss;
            for(auto k : movement){
                ll xx = x + k.ff, yy = y + k.ss;
                if(xx >= 0 && xx < n && yy >= 0 && yy < m){
                    if(level[x][y] + 1 < level[xx][yy]){
                        Q.push({xx, yy});
                        level[xx][yy] = level[x][y] + 1;
                        ans = max(ans, level[xx][yy]);
                    }
                }
            }
        }
        cout << ans << endl;
        sahil:; 
    }
    return 0;
}

-----------------------------------------------------------------------------

                            (Dijstra)
                            
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        int u = times.size(), v = times[0].size();
        vector<vector<pair<int, int>>> graph(n + 1);
        for(int i = 0; i < u; i++){
            graph[times[i][0]].push_back({times[i][1], times[i][2]});
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, k});
        vector<bool> visited(n + 1, false);
        vector<int> level(n + 1, INT_MAX);
        level[k] = 0;
        while(!Q.empty()){
            auto i = Q.top();
            Q.pop();
            int x = i.first, y = i.second;
            if(visited[y]){
                continue;
            }
            visited[y] = true;
            for(auto child : graph[y]){
                int xx = child.first;
                int yy = child.second;
                if(level[y] + yy < level[xx]){
                    level[xx] = level[y] + yy;
                    Q.push({level[xx], xx});
                }
            }
        }
        int ans = INT_MIN;
        for(int i = 1; i <= n; i++){
            ans = max(ans, level[i]);
        }
        return ans == INT_MAX ? -1 : ans;
    }
};

O(E(log(V)))

--------------------------------------------------------------------------------------------------

                              (Floyd Warshall)

vector<vector<ll>> dist(n, vector<ll> (n, INT_MAX));
    fori(i, 0, n){
        fori(j, 0, n){
            if(i == j){
                dist[i][j] = 0;
            }
        }
    }
    fori(i, 0, m){
        ll u, v, wt; cin >> u >> v >> wt;
        dist[u][v] = wt;
    }
    fori(via, 0, n){
        fori(i, 0, n){
            fori(j, 0, n){
                if(dist[i][via] != INT_MAX && dist[via][j] != INT_MAX){
                    dist[i][j] = min(dist[i][j], dist[i][via] + dist[via][j]);
                }
            }
        }
    }

city[i][i] < 0 negetive cyclle
    
-------------------------------------------------------------------------------------------------

                            (Kruskal's Algo) - Minimum spanning tree

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); 
    ll T = 1;
    // cin >> T;
    while(T--){
        ll n; cin >> n;
        dsu<ll> obj(n);
        vector<pair<ll, ll>> yam(n + 1);
        fori(i, 1, n + 1){
            cin >> yam[i].ff >> yam[i].ss;
        }
        // cp(yam);
        vector<ll> cost(n + 1);
        fori(i, 1, n + 1){
            cin >> cost[i];
        }
        vector<ll> dist(n + 1);
        fori(i, 1, n + 1){
            cin >> dist[i];
        }
        vector<pair<ll, pair<ll, ll>>> edges;
        fori(i, 1, n + 1){
            edges.pb({cost[i], {0, i}});
        }
        fori(i, 1, n + 1){
            fori(j, i + 1, n + 1){
                ll wire = abs(yam[i].ff - yam[j].ff) + abs(yam[i].ss - yam[j].ss);
                ll pdu = wire * (dist[i] + dist[j]);
                edges.pb({pdu , {i, j}});
            }
        }
        sort(all(edges));
        ll final = 0;
        vector<ll> power;
        vector<pair<ll, ll>> couple;
        for(auto i : edges){
            ll wt = i.ff;
            ll u = i.ss.ff;
            ll v = i.ss.ss;
            if(obj.getp(u) == obj.getp(v)){
                continue;
            }
            obj.merge(u, v);
            final += wt;
            if(u == 0){
                power.pb(v);
            }else{
                couple.pb({u, v});
            }
        }
        c(final); 
        c(sz(power)); cv(power); 
        c(sz(couple)); cp(couple);
        sahil:; 
    }
    return 0;
}

-------------------------------------------------------------------------

Bieperitie graph is linear and even cycle length if odd length then not bipertite graph

class Solution {
public:
    bool isBipartite(vector<vector<int>>& v) {
        int n = v.size();
        vector<int> visited(n, 0);
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                queue<pair<int, int>> Q;
                Q.push({i, -1});
                visited[i] = -1;
                while(!Q.empty()){
                    auto k = Q.front();
                    Q.pop();
                    int x = k.first, y = k.second;
                    for(auto child : v[x]){
                        if(visited[child]){
                            if(visited[x] == visited[child]){
                                return false;
                            }else{
                                continue;
                            }
                        }
                        visited[child] = (visited[x] == -1) ? 1 : -1;
                        Q.push({child, x});
                    }
                }
            }
        }
        return true;
    }
};

class Solution {
public:

    bool dfs(int vertex, int color, vector<vector<int>> &v, vector<int> &visited){
        bool loop = false;
        visited[vertex] = color;
        for(auto child : v[vertex]){
            if(visited[child]){
                if(visited[child] == visited[vertex]){
                    return true;
                }else{
                    continue;
                }
            }
            loop |= dfs(child, visited[vertex] == -1 ? 1 : -1, v, visited);
        }
        return loop;
    }

    bool isBipartite(vector<vector<int>>& v) {
        int n = v.size();
        vector<int> visited(n, 0);
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                if(dfs(i, -1, v, visited)){
                    return false;
                }
            }
        }
        return true;
    }
};

---------------------------------------------------------------------------------------

                        (Topologgical sort) for DAG

void dfs(int vertex, vector<bool> &visited, vector<int> adj[], stack<int> &st){
	    visited[vertex] = true;
	    for(auto child : adj[vertex]){
	        if(!visited[child]){
	            dfs(child, visited, adj, st);
	        }
	    }
	    st.push(vertex);
	}
	
	//Function to return list containing vertices in Topological order. 
	vector<int> topoSort(int V, vector<int> adj[]) 
	{
	    int n = V;
	    stack<int> st;
	    vector<bool> visited(n, false);
	    for(int i = 0; i < n; i++){
	        if(!visited[i]){
	            dfs(i, visited, adj, st);
	        }
	    }
	    vector<int> ans;
	    while(!st.empty()){
	        ans.push_back(st.top());
	        st.pop();
	    }
	    return ans;
	}
	
	
	(Khan's algo)

vector<int> topoSort(int V, vector<int> adj[]) 
	{
	    int n = V;
	    vector<int> in(n, 0);
	    for(int i = 0; i < n; i++){
	        for(auto child : adj[i]){
	            in[child] += 1;
	        }
	    }
	    queue<int> Q;
	    for(int i = 0; i < n; i++){
	        if(!in[i]){
	            Q.push(i);
	        }
	    }
	    vector<int> ans;
	    while(!Q.empty()){
	        auto vertex = Q.front();
	        Q.pop();
	        ans.push_back(vertex);
	        for(auto child : adj[vertex]){
	            in[child] -= 1;
	            if(!in[child]){
	                Q.push(child);
	            }
	        }
	    }
	    return ans;
	}

---------------------------------------------------------------------------

			(Belmen ford)

to detect negative cycle --> do n - 1 itreation and store distance in array

vector<int> bellman_ford(int n, vector<vector<int>>& v, int S) {
        vector<int> dist(n, 1e8);
        dist[S] = 0;
        for(int i = 0; i < n - 1; i++){
            for(auto it : v){
                int u = it[0], w = it[1], wt = it[2];
                if(dist[u] + wt < dist[w]){
                    dist[w] = dist[u] + wt;
                }
            }
        }
        for(auto it : v){
            int u = it[0], w = it[1], wt = it[2];
            if(dist[u] + wt < dist[w]){
                return {-1};
            }
        }
        return dist;
    }

if on nTH itreation if i get updated distance so it has negetive cycle.

