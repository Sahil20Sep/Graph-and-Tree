ancestors --> parent, grandparent, ettc..

full binary tree -- > all node have 0 or 2 children

complete binary tree --> all level are completyly filled except the last level and in last level all node as left side as possible

perfect binary tree --> all leaf node has to be in same level

degenerate tree --> every node have signle children || starigh line

struct node
{
    int data;
    struct node *left;
    struct node *right;

    node (int val){
        data = val;
        left = right = NULL;
    }
};

struct node *root = new node(1);
root -> left = new node(2);
root -> right = new node(3);
root -> left -> right = new node(5);

(DFS)

inorder --> left root right

preorder --> root left right

postorder --> left right root

        1
    2      3
4    5   6     7

inorder --> 4 2 5 1 6 3 7

preorder --> 1 2 4 5 3 6 7

postorder --> 4 5 2 6 7 3 1

(BFS)

level wise

-----------------------------------------------------------

      (PRE ORDER TRAVESER)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void preorder(TreeNode* root, vector<int> &ans){
        if(root == NULL){
            return;
        }

        ans.push_back(root -> val);

        preorder(root -> left, ans);

        preorder(root -> right, ans);
    }

    vector<int> preorderTraversal(TreeNode* root) {

        if(root == NULL){
            return {};
        }

        vector<int> ans;

        // preorder(root, ans);

        stack<TreeNode*> st; 

        st.push(root);

        while(!st.empty()){
            root = st.top(); 
            st.pop();

            ans.push_back(root -> val);

            if(root -> right != NULL){
                st.push(root -> right);
            }

            if(root -> left != NULL){
                st.push(root -> left);
            }
        }

        return ans;

    }
};

TIME --> O(N) , SPACE --> O(N) or in itretive O(height)

-------------------------------------------------------------------

          (INORDER)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void inorder(TreeNode* root, vector<int> &ans){

        if(root == NULL){
            return ;
        }

        inorder(root -> left, ans);

        ans.push_back(root -> val);

        inorder(root -> right, ans);

    }

    vector<int> inorderTraversal(TreeNode* root) {
        
        vector<int> ans;

        // inorder(root, ans);

        stack<TreeNode*> st;

        auto node = root;

        while(1){
            if(node != NULL){
                st.push(node);
                node = node -> left;
            }else{
                if(st.empty()){
                    break;
                }
                node = st.top();
                st.pop();
                ans.push_back(node -> val);
                node = node -> right;
            }
        }

        return ans;
    }
};

------------------------------------------------------------------------

        (postorder)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void postorder(TreeNode* root, vector<int> &ans){

        if(root == NULL){
            return ;
        }

        postorder(root -> left, ans);

        postorder(root -> right, ans);

        ans.push_back(root -> val);

    }

    vector<int> postorderTraversal(TreeNode* root) {

        if(root == NULL){
            return {};
        }
        
        vector<int> ans;

        // postorder(root, ans);

        stack<TreeNode*> st;

        auto current = root;

        while(!st.empty() || current != NULL){
            if(current != NULL){

                st.push(current);

                current = current -> left;

            }else{

                auto temp = st.top() -> right;

                if(temp == NULL){

                    temp = st.top();
                    st.pop();
                    ans.push_back(temp -> val);

                    while(!st.empty() && temp == st.top() -> right){
                        temp = st.top();
                        st.pop();
                        ans.push_back(temp -> val);
                    }

                }else{

                    current = temp;

                }
            }
        }

        return ans;
    }
};

--------------------------------------------------------------------------------------------

              (BFS)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

        if(root == NULL){
            return {};
        }
        
        vector<vector<int>> ans;

        vector<int> store;

        queue<TreeNode*> Q;

        Q.push(root);

        while(!Q.empty()){
            
            auto s = Q.size();

            while(s--){
                auto f = Q.front();
                Q.pop();
                store.push_back(f -> val);

                if(f -> left != NULL){
                    Q.push(f -> left);
                }
                
                if(f -> right != NULL){
                    Q.push(f -> right);
                }
            }

            ans.push_back(store);

            store.clear();

        }

        return ans;

    }
};

TIME --> O(N) , SPACE --> O(N)

--------------------------------------------------------------------------------------
                    (all in one)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:

    vector<int> postorderTraversal(TreeNode* root) {

        if(root == NULL){
            return {};
        }
        
        vector<int> pre, in, post;

        stack<pair<TreeNode*, int>> st;

        st.push({root, 1});

        while(!st.empty()){
            auto f = st.top();
            st.pop();

            auto root = f.first;
            auto num = f.second;

            if(num == 1){
                pre.push_back(root -> val);
                st.push({root, num + 1});

                if(root -> left != NULL){
                    st.push({root -> left, 1});
                }
            }
            else if(num == 2){
                in.push_back(root -> val);
                st.push({root, num + 1});

                if(root -> right != NULL){
                    st.push({root -> right, 1});
                }
            }
            else{
                post.push_back(root -> val);
            }
        }

        return post;
    }
};

--------------------------------------------------------------------------

                (Depth)

class Solution {
public:
    int maxDepth(TreeNode* root) {

        if(root == NULL){
            return 0;
        }
        
        queue<TreeNode*> Q;
        Q.push(root);

        int cnt = 0;

        while(!Q.empty()){
            auto s = Q.size();
            cnt++;

            while(s--){
                auto f = Q.front();
                Q.pop();

                if(f -> left != NULL){
                    Q.push(f -> left);
                }

                if(f -> right != NULL){
                    Q.push(f -> right);
                }
            }
        }

        return cnt;
    }
};

class Solution {
public:

    int depth(TreeNode* root){
        if(root == NULL && root == NULL){
            return 0;
        }

        return 1 + max(depth(root -> left), depth(root -> right));
    }

    int maxDepth(TreeNode* root) {

        if(root == NULL){
            return 0;
        }
        
        return depth(root);

    }
};

time --> O(N) space --> O(N)

------------------------------------------------------------------------

            (check balance or not)

class Solution {
public:

    bool flag = true;

    int depth(TreeNode* root){

        if(root == NULL){
            return 0;
        }

        int left = depth(root -> left);

        int right = depth(root -> right);

        if(abs(left - right) > 1){
            flag = false;
        }

        return 1 + max(left, right);

    }

    bool isBalanced(TreeNode* root) {
        
        if(root == NULL){
            return true;
        }

        depth(root);

        return flag;

    }
};

class Solution {
public:

    int depth(TreeNode* root){

        if(root == NULL){
            return 0;
        }

        int left = depth(root -> left);

        int right = depth(root -> right);

        if(abs(left - right) > 1 || left == 1e9 || right == 1e9){
            return 1e9;
        }

        return 1 + max(left, right);

    }

    bool isBalanced(TreeNode* root) {
        
        if(root == NULL){
            return true;
        }

        if(depth(root) == 1e9){
            return false;
        }

        return true;

    }
};

-----------------------------------------------------------------------

            (diameter of tree)

class Solution {
public:

    int mx = 0;

    int dia(TreeNode* root){

        if(root == NULL){
            return 0;
        }

        int left = dia(root -> left);

        int right = dia(root -> right);

        mx = max(mx, left + right);

        return 1 + max(left, right); 

    }

    int diameterOfBinaryTree(TreeNode* root) {
        
        dia(root);

        return mx;

    }
};

-------------------------------------------------------------------------------

            (maximum path sum)

class Solution {
public:

    int mx = -1e9;

    int func(TreeNode* root){
        
        if(root == NULL){
            return 0;
        }

        int dabi = max(0, func(root -> left));

        int jmni = max(0, func(root -> right));

        mx = max(mx, root -> val + dabi + jmni);

        return root -> val + max(dabi, jmni);
    }

    int maxPathSum(TreeNode* root) {
        
        func(root);

        return mx;

    }
};

----------------------------------------------------------------------------

                (Tree is same or not)

class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {

        if((p == NULL && q != NULL) || (p != NULL && q == NULL)){
            return false;
        }

        if(p == NULL && q == NULL){
            return true;
        }

        if(p -> val != q -> val){
            return false;
        }

        bool flag = true;

        flag &= isSameTree(p -> left, q -> left);
        flag &= isSameTree(p -> right, q -> right);

        return flag;

    }
};

----------------------------------------------------------------------------

            zig zag


class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {

        if(root == NULL){
            return {};
        }

        queue<TreeNode*> Q;
        Q.push(root);

        vector<vector<int>> ans;

        vector<int> store;

        int cnt = 0;

        while(!Q.empty()){
            auto s = Q.size();

            while(s--){

                auto f = Q.front();
                Q.pop();

                store.push_back(f -> val);

                if(f -> left != NULL){
                    Q.push(f -> left);
                }

                if(f -> right != NULL){
                    Q.push(f -> right);
                }

            }

            if(cnt & 1){
                reverse(store.begin(), store.end());
            }

            ans.push_back(store);

            store.clear();

            cnt++;

        }

        return ans;

    }
};

-----------------------------------------------------------------------------------------------------------------------

                        (boundry anticlock traveser)

#include <bits/stdc++.h> 
/************************************************************

    Following is the Binary Tree node structure:
    
    template <typename T>
    class TreeNode {
        public :
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~TreeNode() {
            if(left)
                delete left;
            if(right)
                delete right;
        }
    };

************************************************************/

bool isLeaf(TreeNode<int>* root){
    return (root -> left == NULL) && (root -> right == NULL);
}

void addleft(TreeNode<int>* root, vector<int> &ans){

    auto temp = root -> left;

    while(temp != NULL){
        if(!isLeaf(temp)){
            ans.push_back(temp -> data);
        }
        if(temp -> left != NULL){
            temp = temp -> left;
        }else{
            temp = temp -> right;
        }
    }
}

void inorder(TreeNode<int>* root, vector<int> &ans){

    if(isLeaf(root)){
        ans.push_back(root -> data);
        return ;
    }

    if(root -> left != NULL){
        inorder(root -> left, ans);
    }

    if(root -> right != NULL){
        inorder(root -> right, ans);
    }

}

void addright(TreeNode<int>* root, vector<int> &ans){

    auto temp = root -> right;

    stack<int> st;

    while(temp != NULL){
        if(!isLeaf(temp)){
            st.push(temp -> data);
        }
        if(temp -> right != NULL){
            temp = temp -> right;
        }else{
            temp = temp -> left;
        }
    }

    while(!st.empty()){
        ans.push_back(st.top());
        st.pop();
    }
}

vector<int> traverseBoundary(TreeNode<int>* root){
    
    if(root == NULL){
        return {};
    }

    vector<int> ans;

    if(!isLeaf(root)){
        ans.push_back(root -> data);
    }

    addleft(root, ans);

    inorder(root, ans);

    addright(root, ans);

    return ans;

}

-------------------------------------------------------------------------------------------------

                (987. Vertical Order Traversal of a Binary Tree)

class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        
        queue<pair<TreeNode*, pair<int, int>>> Q;
        Q.push({root, {0, 0}});

        map<int, map<int, multiset<int>>> hash;

        while(!Q.empty()){
            auto f = Q.front();
            Q.pop();

            auto vertex = f.first;
            auto vertical = f.second.first, level = f.second.second;

            hash[vertical][level].insert(vertex -> val);

            if(vertex -> left != NULL){
                Q.push({vertex -> left, {vertical - 1, level + 1}});
            }

            if(vertex -> right != NULL){
                Q.push({vertex -> right, {vertical + 1, level + 1}});
            }
        }

        vector<vector<int>> ans;

        vector<int> store;

        for(auto i : hash){
            for(auto j : i.second){
                for(auto it = j.second.begin(); it != j.second.end(); it++){
                    store.push_back(*it);
                }
            }
            ans.push_back(store);
            store.clear();
        }

        return ans;

    }
};

--------------------------------------------------------------------------------------------------------------

            (TOP view) - small change in above code

vector<int> getTopView(TreeNode<int> *root) {

    if(root == NULL){
        return {};
    }
    
    queue<pair<TreeNode<int>*, int>> Q;
    Q.push({root, 0});

    map<int, int> hash;

    while(!Q.empty()){
        auto f = Q.front();
        Q.pop();

        auto vertex = f.first;
        auto vertical = f.second;

        if(hash.find(vertical) == hash.end()){
            hash[vertical] = (vertex -> val);
        }

        if(vertex -> left != NULL){
            Q.push({vertex -> left, vertical - 1});
        }

        if(vertex -> right != NULL){
            Q.push({vertex -> right, vertical + 1});
        }
    }

    vector<int> store;

    for(auto i : hash){
        store.push_back(i.second);
    }

    return store;
}

-------------------------------------------------------------------------------------------------------------

            (Bottam view) - small change in above code

vector<int> bottomView(BinaryTreeNode<int> * root){

    if(root == NULL){
        return {};
    }
    
    queue<pair<BinaryTreeNode<int>*, int>> Q;
    Q.push({root, 0});

    map<int, int> hash;

    while(!Q.empty()){
        auto f = Q.front();
        Q.pop();

        auto vertex = f.first;
        auto vertical = f.second;

        hash[vertical] = (vertex -> data);

        if(vertex -> left != NULL){
            Q.push({vertex -> left, vertical - 1});
        }

        if(vertex -> right != NULL){
            Q.push({vertex -> right, vertical + 1});
        }
    }

    vector<int> store;

    for(auto i : hash){
        store.push_back(i.second);
    }

    return store;
    
}

in this view petter we can not implement recursive because of depth, so we have to pareeller introduce some height concept

-----------------------------------------------------------------------------------------------------------------------------

                    (right view)

class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        if(root == NULL){
            return {};
        }
        
        queue<pair<TreeNode*, int>> Q;
        Q.push({root, 0});

        map<int, int> hash;

        while(!Q.empty()){
            auto f = Q.front();
            Q.pop();

            auto vertex = f.first;
            auto level = f.second;

            hash[level] = vertex -> val;

            if(vertex -> left != NULL){
                Q.push({vertex -> left, level + 1});
            }

            if(vertex -> right != NULL){
                Q.push({vertex -> right, level + 1});
            }
        }

        vector<int> store;

        for(auto it : hash){
            store.push_back(it.second);
        }

        return store;

    }
};

--------------------

class Solution {
public:

    void rightview(TreeNode* root, int level, vector<int> &ans){

        if(root == NULL){
            return ;
        }

        if(level == ans.size()){
            ans.push_back(root -> val);
        }

        rightview(root -> right, level + 1, ans);
        rightview(root -> left, level + 1, ans);

    }

    vector<int> rightSideView(TreeNode* root) {
        if(root == NULL){
            return {};
        }

        vector<int> ans;
        
        rightview(root, 0, ans);

        return ans;

    }
};

------------------------------------------------------------------------------------

            (left view) --> O(N) time and O(H) -- > space

void leftview(TreeNode<int> *root, int level, vector<int> &ans){
    if(root == NULL){
        return;
    }

    if(ans.size() == level){
        ans.push_back(root -> data);
    }

    leftview(root -> left, level + 1, ans);
    leftview(root -> right, level + 1, ans);
}

vector<int> getLeftView(TreeNode<int> *root)
{
    if(root == NULL){
        return {};
    }

    vector<int > ans;

    leftview(root, 0, ans);

    return ans;
    
}

------------------------------------------------------------------------

            (symatric or not)

class Solution {
public:

    bool func(TreeNode* root1, TreeNode* root2){

        if(root1 == NULL || root2 == NULL){
            return (root1 == root2);
        }

        if(root1 -> val != root2 -> val){
            return false;
        }

        bool flag = true;

        flag &= func(root1 -> left, root2 -> right);
        flag &= func(root1 -> right, root2 -> left);

        return flag;

    }

    bool isSymmetric(TreeNode* root) {
        
        if(root == NULL){
            return true;
        }

        return func(root -> left, root -> right);

    }
};

--------------------------------------------------------------------

        (path to node) - itretive

vector<int> Solution::solve(TreeNode* root, int find) {
    
    queue<TreeNode*> Q;
    Q.push(root);
    
    map<int, int> hash;
    
    while(!Q.empty()){
        auto f = Q.front();
        Q.pop();
        
        if(f -> left != NULL){
            hash[f -> left -> val] = f -> val;
            Q.push(f -> left);
        }
        
        if(f -> right != NULL){
            hash[f -> right -> val] = f -> val;
            Q.push(f -> right);
        }
    }
    
    vector<int> ans;
    
    while(hash[find] != 0){
        ans.push_back(find);
        find = hash[find];
    }
    
    ans.push_back(root -> val);
    
    reverse(ans.begin(), ans.end());
    
    return ans;
    
}

        Recursive approcch

bool inorder(TreeNode* root, int find, vector<int> &ans){
    
    if(root == NULL){
        return false;
    }
    
    bool flag = false;
    
    if(root -> val == find){
        ans.push_back(find);
        return true;    
    }
    
    ans.push_back(root -> val);
    
    flag |= inorder(root -> left, find, ans);
    
    flag |= inorder(root -> right, find, ans);
    
    if(!flag){
        ans.pop_back();
    }
    
    return flag;
    
}
 
vector<int> Solution::solve(TreeNode* root, int find) {
    
    vector<int> ans;
    
    inorder(root, find, ans);
    
    return ans;
        
}

--------------------------------------------------------------------------------------------------------------

        (LCA)

class Solution {
public:

    bool inorder(TreeNode* root, int p, vector<TreeNode*> &ans1){
        if(root == NULL){
            return false;
        }

        bool flag = false;

        if(root -> val == p){
            ans1.push_back(root);
            return true;
        }

        ans1.push_back(root);

        flag |= inorder(root -> left, p, ans1);

        flag |= inorder(root -> right, p, ans1);

        if(!flag){
            ans1.pop_back();
        }

        return flag;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        if(root == NULL || p == NULL || q == NULL){
            return root;
        }
        
        vector<TreeNode*> ans1;

        inorder(root, p -> val, ans1);

        vector<TreeNode*> ans2;

        inorder(root, q -> val, ans2);

        TreeNode* lca;

        for(int i = 0; i < min(ans1.size(), ans2.size()); i++){
            if((ans1[i] -> val) == (ans2[i] -> val)){
                lca = ans1[i];
            }else{
                break;
            }
        }

        return lca;

    }
};

--------------------

        (LCA)

class Solution {
public:

    TreeNode* lca(TreeNode* root, TreeNode* p, TreeNode* q){

        if(root == NULL){
            return NULL;
        }

        if(root == p || root == q){
            return root;
        }

        TreeNode *left = lca(root -> left, p, q);

        TreeNode *right = lca(root -> right, p, q);

        if(left == NULL && right == NULL){
            return NULL;
        }

        if(left != NULL && right != NULL){
            return root;
        }

        return left == NULL ? right : left;

    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        return lca(root, p, q);
        
    }
};

----------

class Solution {
public:

    TreeNode* lca(TreeNode* root, TreeNode* p, TreeNode* q){

        if(root == NULL){
            return NULL;
        }

        if(root == p || root == q){
            return root;
        }

        TreeNode *left = lca(root -> left, p, q);

        TreeNode *right = lca(root -> right, p, q);

        if(left == NULL){
            return right;
        }
        if(right == NULL){
            return left;
        }
        return root;

    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        return lca(root, p, q);
        
    }
};

-------------------------------------------------------------------------------------------------------------------------------------

            (maximum width of bt)

class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        
        map<int, int> mn, mx;

        queue<pair<TreeNode*, int>> Q;
        Q.push({root, 0});

        int ans = 0;

        while(!Q.empty()){

            auto s = Q.size();

            auto mn = Q.front().second, mx = Q.back().second;

            ans = max(ans, mx - mn + 1);

            while(s--){
                auto f= Q.front();
                Q.pop();

                auto vertex = f.first;
                auto level = f.second;

                if(vertex -> left != NULL){
                    Q.push({vertex -> left, 2LL * level + 1});
                }

                if(vertex -> right != NULL){
                    Q.push({vertex -> right, 2LL * level + 2});
                }
            }
        }

        return ans;

    }
};

---------------------------------------------------------------------------------------

        (Children sum property)


increse when going down and sum it up when going up

void convertTree(node* root){
    if(root == NULL) return;
     
    int childSum = 0;
     
    if(root->left) childSum+=root->left->data;
    if(root->right) childSum+=root->right->data;
     
    if(childSum>=root->data){
        //change root
        root->data = childSum;
    }
    else{
        //change both children
        if(root->left) root->left->data = root->data;
        if(root->right) root->right->data = root->data;
         
    }
     
    //now go down the tree and check others - Inorder
    convertTree(root->left);
    convertTree(root->right);
     
    //here is the backtracking part happens, as changes may happen
    int totVal = 0;
     
    if(root->left) totVal+=root->left->data;
    if(root->right) totVal+=root->right->data;
     
    // Leaf node dont update, as it will make it 0
    if(root->left || root->right) root->data = totVal;
    //So that at last the children Sum property stays TRUE
 
}

O(n) and O(H)
----------------------------------------------------------------------------------------


